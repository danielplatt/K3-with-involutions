// This code finds explicit polynomials that define the
// involution of the surface X given by the equation
// -xx^3*ww - xx^2*zz*ww + xx^2*ww^2 - xx*yy^3 + xx*zz^3 
// - yy^2*ww^2 + zz^4 + zz*ww^3 = 0.
// The code uses the Riemann-Roch space of 9H-5D
// where H is a hypersurface and D is a twisted
// cubic curve on this hypersurface. 
// The divisor 9H-5D is linearly equivalent to
// the divisor -H+5C where C denotes the special curve 
// of genus 2 and degree 5 on this surface

Q := RationalField();
P1tP1<x0,x1,y0,y1> := ProductProjectiveSpace(Q,[1,1]);

// Curve of type (2,3), genus=2, degree=5
f := x0*x1*y0^3 + x1^2*y0^3 + x0^2*y0*y1^2 + x1^2*y1^3;
C := Scheme(P1tP1,f);
// Embedding in P3
Cim<x,y,z,w> := SegreEmbedding(C);
qc := DefiningEquations(Cim);

// Curve of type (2,1), cubic curve
g := -x1^2*y0 + x0^2*y1;
D := Scheme(P1tP1,g);
// Twisted cubic curve
Dim<x,y,z,w> := SegreEmbedding(D);
qd := DefiningEquations(Dim);

// Union of those curves gives an equation of a 
// quartic in P3
CD := Union(C,D);
CDim<x,y,z,w> := SegreEmbedding(CD);
h := DefiningEquations(CDim)[2];

// Quartic in P3
R<x,y,z,w> := PolynomialRing(Q,4);
P3 := ProjectiveSpace(R);
X := Scheme(P3,h); 

// Curve C and D as curves on X
ConX := Scheme(X,qc);
DonX := Scheme(X,qd);

// Divisors 
DivC := Divisor(X,ConX); 
// It seems like the divisor C is not working 
// in magma, which is odd. 
// We will work around this by using D.
DivD := Divisor(X,DonX);
DivH := Divisor(X,w);

// Basis of Riemann-Roch space of 9H-5D
LB := RiemannRochBasis(9*DivH-5*DivD);
// N.b. takes some time to calculate: ~1min 

// The basis of the Riemann-Roch space of -H+5C
// took to much time.

// We search for a coordinate transformation such 
// that the image under the rational map defined 
// by this basis is again X
// We take four points on X which are pairs that 
// map to each other under the involution:
// [1,-1,-1,1] <--> [0,0,-1,1]
// [1,-1,0,1] <--> [1,0,-1,1]
// This can be checked by slightly adjusting the
// code of Ronald and taking this points as P,
// instead of the generic point.
// Note that all points are on the affine where w
// doesnt vanish.

Pts := [[1,-1,-1,1],[0,0,-1,1],[1,-1,0,1],[1,0,-1,1]];
ev := [[Evaluate(LB[i],Pts[j]) : i in [1..4]]: 
  j in [2,1,4,3]];

MR:=MatrixRing(Q,4);
M:=Transpose(MR!Pts);
N:=Transpose(MR!ev);
LinTr:=M*N^(-1);

Inv:=[&+[LinTr[i,j]*LB[j] : j in [1..4]] : 
  i in [1..4]];
assert [ Evaluate( Inv[i], [1,-1,-1,1]) : 
  i in [1..4]] eq [0,0,-1,1];
assert [ Evaluate( Inv[i], [0,0,-1,1] ) : 
  i in [1..4]] eq [1,-1,-1,1];
assert [ Evaluate( Inv[i], [1,-1,0,1] ) : 
  i in [1..4]] eq [1,0,-1,1];
assert [ Evaluate( Inv[i], [1,0,-1,1] ) : 
  i in [1..4]] eq [1,-1,0,1];
// Hence, the image indeed gives X and so the 
// polynomials of Inv give the involution
[Inv[i] : i in [1..4]]; 


// Now we will calculate different models.
// C+D is linearly equivalent to 2H, so
// |C|=|2H-D|, |3H-C|=|H+D| and |3C|=|6H-3D|


// Model as double cover

L2HmD := RiemannRochBasis(2*DivH-DivD); 
// equations for double cover map
P2<s,t,u> := ProjectiveSpace(Q,2);
phi := map < X -> P2 | L2HmD >; // double cover

L6Hm3D := RiemannRochBasis(6*DivH-3*DivD); 
// gives model in P10, splits via P(1,1,1,3) in
// the following way
f1 := L6Hm3D[3]; 
// appently this one is working, 
// needs more motivation here...
Func := L2HmD;
Func1 := Append(Func,f1); 
// equations for map to P(1,1,1,3)

WPS<xx,yy,zz,ww> := ProjectiveSpace(Q,[1,1,1,3]);
prepi := map < X -> WPS | Func1 >; 
// embedding of X in P(1,1,1,3), 

// The above embedding gives surface: 
// x^5y - x^3y^2z + y^5z + x^4z^2 + xy^3z^2 
//   - y^4z^2 + y^2z^4 + xz^5 + x^3w + x^2yw 
//   - y^3w + w^2 =0 
// in P(1,1,1,3) so there are still linear terms

// Needed a linear map to adjust this embedding
// pi2 := map < WPS -> WPS | 
//    [x,y,z,(w+(x^3+x^2*y-y^3/2))/2]>;
// Image(pi*pi2); 
// Gives surface: 
// x^6 - 2x^5y + x^4y^2 - 2x^3y^3 
// - 2x^2y^4 + y^6 + 4x^3y^2*z - 4y^5z - 4x^4z^2
// - 4xy^3z^2 + 4y^4z^2 - 4y^2z^4 - 4xz^5 - w^2

f2 := (f1+(Func[1]^3+Func[1]^2*Func[2]-Func[2]^3)/2)*2;
Func2 := Append(Func,f2);
pi := map < X -> WPS | Func2 >; 
// embedding of X in P(1,1,1,3) 
X2 := Image(pi); 
X2; // model in P(1,1,1,3),
// equation is given by w^2=f(x,y,z) with f of degree 6

pires := map < X -> X2 | Func2 >; 
// restricted pi to image 
IsInvertible(pires); 
// calculates inverse of pi, takes ~2mpmin

Z0 := Scheme(X2,ww) @@ pires ;
// Branch locus of double cover
// 2*Equations(Z)[1]; 
// equation for the Branch locus on X in P3
// I think something goes wrong because the 
// following gives a different result:
Z1 := Inverse(pires)(Scheme(X2,ww));
// This gives something very ugly...
// Better to pullback f(x,y,z) along phi
Z2p := Scheme(P2,Evaluate(Equation(X2),[s,t,u,0]));

Z2 := Z2p @@ phi; // branched curve in P3;


//Model in P5

LHD := RiemannRochBasis(DivH+DivD);
// equations for map to P5
P5<x0,x1,x2,x3,x4,x5> := ProjectiveSpace(Q,5); 
chi := map < X -> P5 | LHD >; 
// embedding of X in P5

IsIrreducible(X); // needs to be runned to find
X8p := Image(chi); // the image of chi
X8 := Scheme(P5,[Equations(X8p)[i] : i in [4,5,6]]);
X8 eq X8p; 
X8; // model in P5

reschi := map < X -> X8 | LHD >;
IsInvertible(reschi);
