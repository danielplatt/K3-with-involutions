// This code finds explicit polynomials that define the
// involution of the surface X given by the equation
// -xx^3*ww - xx^2*zz*ww + xx^2*ww^2 - xx*yy^3 + xx*zz^3 
// - yy^2*ww^2 + zz^4 + zz*ww^3 = 0.
// The code uses the Riemann-Roch space of 9H-5D
// where H is a hypersurface and D is a twisted
// cubic curve on this hypersurface. 
// The divisor 9H-5D is linearly equivalent to
// the divisor -H+5C where C denotes the special curve 
// of genus 2 and degree 5 on this surface

Q := RationalField();
P1tP1<x0,x1,y0,y1> := ProductProjectiveSpace(Q,[1,1]);

// Curve of type (2,3), genus=2, degree=5
f := x0*x1*y0^3 + x1^2*y0^3 + x0^2*y0*y1^2 + x1^2*y1^3;
C := Scheme(P1tP1,f);
// Embedding in P3
Cim<x,y,z,w> := SegreEmbedding(C);
qc := DefiningEquations(Cim);

// Curve of type (2,1), cubic curve
g := -x1^2*y0 + x0^2*y1;
D := Scheme(P1tP1,g);
// Twisted cubic curve
Dim<x,y,z,w> := SegreEmbedding(D);
qd := DefiningEquations(Dim);

// Union of those curves gives an equation of a 
// quartic in P3
CD := Union(C,D);
CDim<x,y,z,w> := SegreEmbedding(CD);
h := DefiningEquations(CDim)[2];

// Quartic in P3
R<x,y,z,w> := PolynomialRing(Q,4);
P3 := ProjectiveSpace(R);
X := Scheme(P3,h); 

// Curve C and D as curves on X
ConX := Scheme(X,qc);
DonX := Scheme(X,qd);

// Divisors 
DivC := Divisor(X,ConX);
DivD := Divisor(X,DonX);
DivH := Divisor(X,w);

// Basis of Riemann-Roch space of 9H-5D
LB := RiemannRochBasis(9*DivH-5*DivD);
// N.b. takes some time to calculate: ~1min 

// The basis of the Riemann-Roch space of -H+5C
// took to much time.

// We search for a coordinate transformation such 
// that the image under the rational map defined 
// by this basis is again X
// We take four points on X which are pairs that 
// map to each other under the involution:
// [1,-1,-1,1] <--> [0,0,-1,1]
// [1,-1,0,1] <--> [1,0,-1,1]
// This can be checked by slightly adjusting the
// code of Ronald and taking this points as P,
// instead of the generic point.
// Note that all points are on the affine where w
// doesnt vanish.

Pts := [[1,-1,-1,1],[0,0,-1,1],[1,-1,0,1],[1,0,-1,1]];
ev := [[Evaluate(LB[i],Pts[j]) : i in [1..4]]: 
  j in [2,1,4,3]];

MR:=MatrixRing(Q,4);
M:=Transpose(MR!Pts);
N:=Transpose(MR!ev);
LinTr:=M*N^(-1);

F<x,y,z,w>:=FunctionField(Q,4);
Inv:=[&+[w^9*LinTr[i,j]*F!LB[j] : j in [1..4]] : 
  i in [1..4]];
assert [ Evaluate( Inv[i], [1,-1,-1,1]) : 
  i in [1..4]] eq [0,0,-1,1];
assert [ Evaluate( Inv[i], [0,0,-1,1] ) : 
  i in [1..4]] eq [1,-1,-1,1];
assert [ Evaluate( Inv[i], [1,-1,0,1] ) : 
  i in [1..4]] eq [1,0,-1,1];
assert [ Evaluate( Inv[i], [1,0,-1,1] ) : 
  i in [1..4]] eq [1,-1,0,1];
// Hence, the image indeed gives X and so the polynomials 
// of Inv give the involution

// We scale with 32 to get rid of the fractions:
[32*Inv[i] : i in [1..4]]; 



