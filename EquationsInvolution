// This code finds explicit polynomials that define the
// involution of the surface X given by the equation
// -xx^3*ww - xx^2*zz*ww + xx^2*ww^2 - xx*yy^3 + xx*zz^3 
// - yy^2*ww^2 + zz^4 + zz*ww^3 = 0.
// The code uses the Riemann-Roch space of 9H-5D
// where H is a hypersurface and D is a twisted
// cubic curve on this hypersurface. 
// The divisor 9H-5D is linearly equivalent to
// the divisor -H+5C where C denotes the special curve 
// of genus 2 and degree 5 on this surface

Q := RationalField();
P1tP1<x0,x1,y0,y1> := ProductProjectiveSpace(Q,[1,1]);

// Curve of type (2,3), genus=2, degree=5
f := x0*x1*y0^3 + x1^2*y0^3 + x0^2*y0*y1^2 + x1^2*y1^3;
C := Scheme(P1tP1,f);
// Embedding in P3
Cim<x,y,z,w> := SegreEmbedding(C);
qc := DefiningEquations(Cim);

// Curve of type (2,1), cubic curve
g := -x1^2*y0 + x0^2*y1;
D := Scheme(P1tP1,g);
// Twisted cubic curve
Dim<x,y,z,w> := SegreEmbedding(D);
qd := DefiningEquations(Dim);

// Union of those curves gives an equation of a 
// quartic in P3
CD := Union(C,D);
CDim<x,y,z,w> := SegreEmbedding(CD);
h := DefiningEquations(CDim)[2];

// Quartic in P3
R<x,y,z,w> := PolynomialRing(Q,4);
P3 := ProjectiveSpace(R);
X := Scheme(P3,h); 

// Curve C and D as curves on X
ConX := Scheme(X,qc);
DonX := Scheme(X,qd);

// Divisors 
DivC := Divisor(X,ConX); 
// It seems like the divisor C is not working 
// in magma, which is odd. 
// We will work around this by using D.
DivD := Divisor(X,DonX);
DivH := Divisor(X,w);

F<x,y,z,w>:=FunctionField(Q,4);

// Basis of Riemann-Roch space of 9H-5D
LB := RiemannRochBasis(9*DivH-5*DivD);
// N.b. takes some time to calculate: ~1min 

// The basis of the Riemann-Roch space of -H+5C
// took to much time.

// We search for a coordinate transformation such 
// that the image under the rational map defined 
// by this basis is again X
// We take four points on X which are pairs that 
// map to each other under the involution:
// [1,-1,-1,1] <--> [0,0,-1,1]
// [1,-1,0,1] <--> [1,0,-1,1]
// This can be checked by slightly adjusting the
// code of Ronald and taking this points as P,
// instead of the generic point.
// Note that all points are on the affine where w
// doesnt vanish.

Pts := [[1,-1,-1,1],[0,0,-1,1],[1,-1,0,1],[1,0,-1,1]];
ev := [[Evaluate(LB[i],Pts[j]) : i in [1..4]]: 
  j in [2,1,4,3]];

MR:=MatrixRing(Q,4);
M:=Transpose(MR!Pts);
N:=Transpose(MR!ev);
LinTr:=M*N^(-1);

Inv:=[&+[w^9*LinTr[i,j]*F!LB[j] : j in [1..4]] : 
  i in [1..4]];
assert [ Evaluate( Inv[i], [1,-1,-1,1]) : 
  i in [1..4]] eq [0,0,-1,1];
assert [ Evaluate( Inv[i], [0,0,-1,1] ) : 
  i in [1..4]] eq [1,-1,-1,1];
assert [ Evaluate( Inv[i], [1,-1,0,1] ) : 
  i in [1..4]] eq [1,0,-1,1];
assert [ Evaluate( Inv[i], [1,0,-1,1] ) : 
  i in [1..4]] eq [1,-1,0,1];
// Hence, the image indeed gives X and so the 
// polynomials of Inv give the involution

// We scale with 32 to get rid of the fractions:
[32*Inv[i] : i in [1..4]]; 


// Now we will calculate different models.
// C+D is linearly equivalent to 2H, so
// |C|=|2H-D|, |3H-C|=|H+D| and |3C|=|6H-3D|

LHD := RiemannRochBasis(DivH+DivD);
Func0 := [ w*F!LHD[i] : i in [1..6]]; 
// equations for map to P5

P5 := ProjectiveSpace(Q,5); 
chi := map < X -> P5 | Func0 >; 
// embedding of X in P5

// Image(chi);
// to find equations for the model in P5 it seems 
// like it takes to much time for Magma

L2HmD := RiemannRochBasis(2*DivH-DivD); 
Func := [ w^2*F!L2HmD[i] : i in [1..3]]; 
// equations for double cover map

P2 := ProjectiveSpace(Q,2);
phi := map < X -> P2 | Func >; // double cover


L6Hm3D := RiemannRochBasis(6*DivH-3*DivD); 
// gives model in P10, splits via P(1,1,1,3) in
// the following way
f1 := w^6*F!L6Hm3D[3]; 
// appently this one is working, 
// needs more motivation here...
Func1 := Append(Func,f1); 
// equations for map to P(1,1,1,3)

WPS<xx,yy,zz,ww> := ProjectiveSpace(Q,[1,1,1,3]);
prepi := map < X -> WPS | Func1 >; 
// embedding of X in P(1,1,1,3), 

// The above embedding gives surface: 
// x^5y - x^3y^2z + y^5z + x^4z^2 + xy^3z^2 
//   - y^4z^2 + y^2z^4 + xz^5 + x^3w + x^2yw 
//   - y^3w + w^2 =0 
// in P(1,1,1,3) so there are still linear terms

// Needed a linear map to adjust this embedding
// pi2 := map < WPS -> WPS | 
//    [x,y,z,w+(x^3+x^2*y-y^3)/2]>;
// Image(pi*pi2); 
// Gives surface: x^6 - 2x^5y + x^4y^2 - 2x^3y^3 
// - 2x^2y^4 + y^6 + 4x^3y^2*z - 4y^5z - 4x^4z^2
// - 4xy^3z^2 + 4y^4z^2 - 4y^2z^4 - 4xz^5 - 4w^2

f2 := f1+(Func[1]^3+Func[1]^2*Func[2]-Func[2]^3)/2;
Func2 := Append(Func,f2);
pi := map < X -> WPS | Func2 >; 
// embedding of X in P(1,1,1,3) 
Y := Image(pi); 
Y; // image w^2=f(x,y,z) with f of degree 6

pires := map < X -> Y | Func2 >; 
// restricted pi to image 
IsInvertible(pires); 
// calculates inverse of pi

Z := Scheme(Y,ww) @@ pires 
// Branch locus of double cover
2*Equations(Z)[1]; 
// equation for the Branch locus on X in P3

// Probably, we can do better then this
// but for now it works..
